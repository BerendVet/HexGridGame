[{"D:\\Projects\\HexGridGame\\src\\index.tsx":"1","D:\\Projects\\HexGridGame\\src\\App.tsx":"2","D:\\Projects\\HexGridGame\\src\\Game.tsx":"3","D:\\Projects\\HexGridGame\\src\\factions.js":"4","D:\\Projects\\HexGridGame\\src\\Tile.tsx":"5","D:\\Projects\\HexGridGame\\src\\Sidebar.tsx":"6","D:\\Projects\\HexGridGame\\src\\Canvas.tsx":"7","D:\\Projects\\HexGridGame\\src\\Color.tsx":"8","D:\\Projects\\HexGridGame\\src\\components\\index.js":"9","D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\index.jsx":"10","D:\\Projects\\HexGridGame\\src\\components\\Button\\index.jsx":"11","D:\\Projects\\HexGridGame\\src\\components\\Modal\\index.jsx":"12","D:\\Projects\\HexGridGame\\src\\components\\ProgressBar\\index.jsx":"13","D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CentralButton.jsx":"14","D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CircleMenuWrapper.jsx":"15","D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\SubMenuItem.jsx":"16","D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CircleMenuItem.jsx":"17"},{"size":232,"mtime":1612354381252,"results":"18","hashOfConfig":"19"},{"size":152,"mtime":1612354381246,"results":"20","hashOfConfig":"19"},{"size":5970,"mtime":1612522417462,"results":"21","hashOfConfig":"19"},{"size":461,"mtime":1612354381252,"results":"22","hashOfConfig":"19"},{"size":1860,"mtime":1612435715786,"results":"23","hashOfConfig":"19"},{"size":1930,"mtime":1612354381248,"results":"24","hashOfConfig":"19"},{"size":15464,"mtime":1612522375938,"results":"25","hashOfConfig":"19"},{"size":801,"mtime":1612354381247,"results":"26","hashOfConfig":"19"},{"size":198,"mtime":1612354381252,"results":"27","hashOfConfig":"19"},{"size":3197,"mtime":1612354381250,"results":"28","hashOfConfig":"19"},{"size":1089,"mtime":1612354381249,"results":"29","hashOfConfig":"19"},{"size":2928,"mtime":1612520646871,"results":"30","hashOfConfig":"19"},{"size":2378,"mtime":1612354381251,"results":"31","hashOfConfig":"19"},{"size":1798,"mtime":1612354381249,"results":"32","hashOfConfig":"19"},{"size":1623,"mtime":1612354381249,"results":"33","hashOfConfig":"19"},{"size":1822,"mtime":1612354381250,"results":"34","hashOfConfig":"19"},{"size":2133,"mtime":1612354381249,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"mwz7hg",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"38"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"38"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},"D:\\Projects\\HexGridGame\\src\\index.tsx",[],["75","76"],"D:\\Projects\\HexGridGame\\src\\App.tsx",[],"D:\\Projects\\HexGridGame\\src\\Game.tsx",["77"],"D:\\Projects\\HexGridGame\\src\\factions.js",[],["78","79"],"D:\\Projects\\HexGridGame\\src\\Tile.tsx",[],"D:\\Projects\\HexGridGame\\src\\Sidebar.tsx",["80","81","82"],"import React, { Component } from 'react'\r\nimport { Button, Modal } from './components'\r\nimport './Sidebar.css'\r\n\r\ninterface SidebarProps {\r\n    selectedTile,\r\n    board,\r\n\r\n    // callback functions\r\n}\r\n\r\nexport default class Sidebar extends React.Component<SidebarProps> {\r\n\r\n    constructor(props) {\r\n        super(props)\r\n    }\r\n\r\n    deletePop(index) {\r\n        this.props.selectedTile.deletePop(index);\r\n        this.forceUpdate();\r\n    }\r\n\r\n    raiseUnit(index) {\r\n        this.props.selectedTile.raiseUnit(index);\r\n        this.forceUpdate();\r\n    }\r\n\r\n    disbandUnit(index) {\r\n        this.props.selectedTile.disbandUnit(index);\r\n        this.forceUpdate();\r\n    }\r\n\r\n    addPop() {\r\n        this.props.selectedTile.addPop();\r\n        this.forceUpdate();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"sidenav\">\r\n\r\n                {this.props.selectedTile != null &&\r\n                    <div>\r\n                        <h2>{this.props.selectedTile.control.name}</h2>\r\n                        <Button onClick={() => this.addPop()}>Add Pop</Button>\r\n                        <ul>\r\n                            <h3>Population</h3>\r\n                            {this.props.selectedTile.population.map((value, index) => {\r\n                                return <li key={index}>{value.allegiance.name} <Button onClick={() => this.raiseUnit(index)}>Raise unit</Button></li>\r\n                            })}\r\n                        </ul>\r\n                        <ul>\r\n                            <h3>Units</h3>\r\n                            {this.props.selectedTile.units.map((value, index) => {\r\n                                return <li key={index}>{value.allegiance.name} <Button onClick={() => this.disbandUnit(index)}>Disband unit</Button></li>\r\n                            })}\r\n                        </ul>\r\n                    </div>\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","D:\\Projects\\HexGridGame\\src\\Canvas.tsx",["83","84","85","86","87","88","89","90"],"import React from 'react'\r\nimport './Canvas.css'\r\nimport { Color } from './Color';\r\n\r\ninterface CanvasProps {\r\n    // board object\r\n    board,\r\n\r\n    // callback functions\r\n    selectTile,\r\n    moveUnits,\r\n}\r\n\r\n\r\nexport default class Canvas extends React.Component<CanvasProps> {\r\n\r\n    // canvas layers\r\n    canvasHex: any;\r\n    canvasOverlay: any;\r\n    canvasUnits: any;\r\n\r\n    canvasContainer: any;\r\n\r\n    // object properties check equality function\r\n    isEqual = (...objects: any) => objects.every((obj: any) => JSON.stringify(obj) === JSON.stringify(objects[0]));\r\n\r\n    // hex constants\r\n    hexSize = 40;\r\n    hexHeight = this.hexSize * 2;\r\n    hexWidth = Math.sqrt(3) * this.hexSize;\r\n    vertDistance = this.hexHeight * 3 / 4;\r\n    horizDistance = this.hexWidth;\r\n    hexOrigin = { x: this.hexSize * 2, y: this.hexSize * 2 }\r\n\r\n    gridWidth = this.horizDistance * (this.props.board.columns + 2);\r\n    gridHeight = this.vertDistance * (this.props.board.rows + 2)\r\n\r\n    canvasWidth = Math.min(this.gridWidth)\r\n    canvasHeight = this.vertDistance * (this.props.board.rows + 2)\r\n\r\n    // canvasOffset = { x: -0.5, y: -0.5 };\r\n\r\n    debugMode = false;\r\n\r\n    dragging = false;\r\n    firstDragPosition = { x: 0, y: 0 };\r\n    lastDragPosition = { x: 0, y: 0 };\r\n    dragMargin = { x: 0, y: 0 }\r\n\r\n    scale = 1;\r\n    MIN_ZOOM = 0.1\r\n    MAX_ZOOM = 2\r\n    SCROLL_SENSITIVITY = 0.0005\r\n\r\n    constructor(props) {\r\n        super(props)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.canvasHex.width = this.canvasWidth;\r\n        this.canvasHex.height = this.canvasHeight;\r\n\r\n        this.canvasOverlay.width = this.canvasWidth;\r\n        this.canvasOverlay.height = this.canvasHeight;\r\n\r\n        this.canvasUnits.width = this.canvasWidth;\r\n        this.canvasUnits.height = this.canvasHeight;\r\n\r\n        window.addEventListener('resize', () => {\r\n            this.updateGridTransformation();\r\n        })\r\n        this.clampZoom()\r\n        this.scale = this.MIN_ZOOM;\r\n\r\n        this.updateGridTransformation();\r\n\r\n        this.drawUnitCanvas();\r\n\r\n        this.drawHexGrid();\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        if (this.state != undefined) {\r\n            if (!this.isEqual(nextState, this.state)) {\r\n                this.clearHexOverlay()\r\n                if ((nextState as any).highlightedHex != null) {\r\n                    let hex = (nextState as any).highlightedHex;\r\n                    var center = this.hexToPixel(hex)\r\n                    var tile = this.props.board.grid[hex.x][hex.y]\r\n                    this.drawHex(this.canvasOverlay.getContext('2d'), center, tile.color.getOppositeStringNotation(), 3)\r\n                }\r\n                if ((nextState as any).selectedHex != null) {\r\n                    let hex = (nextState as any).selectedHex;\r\n                    var center = this.hexToPixel(hex)\r\n                    var tile = this.props.board.grid[hex.x][hex.y]\r\n                    this.drawHex(this.canvasOverlay.getContext('2d'), center, \"white\", 3)\r\n\r\n                    if (tile.units.length > 0) {\r\n                        this.getNeighbors(hex).forEach((n) => {\r\n                            this.drawHex(this.canvasOverlay.getContext('2d'), this.hexToPixel(n), \"white\", 3)\r\n                        })\r\n                    }\r\n\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    retrieveHexFromMouseEvent(e) {\r\n        var x;\r\n        var y;\r\n        if (e.pageX || e.pageY) {\r\n            x = e.pageX;\r\n            y = e.pageY;\r\n        }\r\n        else {\r\n            x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\r\n            y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\r\n        }\r\n\r\n        x -= this.canvasOverlay.offsetLeft;\r\n        y -= this.canvasOverlay.offsetTop;\r\n\r\n        x /= this.scale;\r\n        y /= this.scale;\r\n\r\n        x -= this.dragMargin.x;\r\n        y -= this.dragMargin.y\r\n\r\n        return this.pixelToHex(this.Point(x, y))\r\n    }\r\n\r\n    handleMouseUp(e) {\r\n        this.dragging = false;\r\n\r\n        var hex = this.retrieveHexFromMouseEvent(e);\r\n        if (hex.x < 0 || hex.x >= this.props.board.columns\r\n            || hex.y < 0 || hex.y >= this.props.board.rows) {\r\n            return;\r\n        }\r\n\r\n        // if user is not dragging\r\n        if (e.pageX == this.firstDragPosition.x && e.pageY == this.firstDragPosition.y) {\r\n\r\n            if ((this.state as any).selectedHex == null) {\r\n                // select clicked tile\r\n                this.setState({\r\n                    selectedHex: hex,\r\n                })\r\n                this.props.selectTile(this.props.board.grid[hex.x][hex.y])\r\n            } else if (this.getNeighbors((this.state as any).selectedHex).some((n) => n.x === hex.x && n.y === hex.y)) {\r\n                let selectedHex = (this.state as any).selectedHex\r\n                let from = this.props.board.grid[selectedHex.x][selectedHex.y]\r\n                if(from.units.length > 0) {\r\n                    let to = this.props.board.grid[hex.x][hex.y]\r\n                    this.props.moveUnits(from, to)\r\n                }\r\n\r\n                // deselect clicked tile\r\n                this.setState({\r\n                    selectedHex: null,\r\n                })\r\n                this.props.selectTile(null)\r\n            } else {\r\n                // deselect clicked tile\r\n                this.setState({\r\n                    selectedHex: null,\r\n                })\r\n                this.props.selectTile(null)\r\n            }\r\n\r\n\r\n        }\r\n        this.firstDragPosition = null;\r\n\r\n    }\r\n\r\n    handleMouseDown(e) {\r\n        this.dragging = true;\r\n\r\n        this.firstDragPosition = { x: e.clientX, y: e.clientY }\r\n        this.lastDragPosition = { x: e.clientX, y: e.clientY };\r\n    }\r\n\r\n    handleMouseOut(e) {\r\n        this.dragging = false;\r\n    }\r\n\r\n    updateGridTransformation() {\r\n        if (this.canvasContainer != null) {\r\n            let minDragMargin = {\r\n                x: this.clamp(this.dragMargin.x, -(((this.canvasWidth * this.scale) - this.canvasContainer.offsetWidth)) / this.scale, 0),\r\n                y: this.clamp(this.dragMargin.y, -(((this.canvasHeight * this.scale) - window.innerHeight)) / this.scale, 0)\r\n            }\r\n            this.dragMargin.x = minDragMargin.x > 0 ? minDragMargin.x / 2 : this.clamp(this.dragMargin.x, minDragMargin.x, 0);\r\n            this.dragMargin.y = minDragMargin.y > 0 ? minDragMargin.y / 2 : this.clamp(this.dragMargin.y, minDragMargin.y, 0)\r\n\r\n            let transformOrigin = `0 0`;\r\n            let transform = `scale(${this.scale}) translate(${this.dragMargin.x}px, ${this.dragMargin.y}px)`;\r\n\r\n            this.canvasHex.style.transformOrigin = transformOrigin\r\n            this.canvasHex.style.transform = transform;\r\n\r\n            this.canvasUnits.style.transformOrigin = transformOrigin\r\n            this.canvasUnits.style.transform = transform;\r\n\r\n            this.canvasOverlay.style.transformOrigin = transformOrigin\r\n            this.canvasOverlay.style.transform = transform\r\n        }\r\n    }\r\n\r\n    clampZoom() {\r\n        // get min zoom from current window size\r\n        this.MIN_ZOOM = Math.min(window.innerWidth / this.canvasWidth, window.innerHeight / this.canvasHeight);\r\n        // clamp current zoom level from min and max levels\r\n        this.scale = Math.min(this.scale, this.MAX_ZOOM)\r\n        this.scale = Math.max(this.scale, this.MIN_ZOOM)\r\n    }\r\n\r\n    handleWheel(e) {\r\n        let mouse = {\r\n            x: e.pageX,\r\n            y: e.pageY\r\n        }\r\n        var hex = this.retrieveHexFromMouseEvent(e);\r\n\r\n        let delta = e.deltaY * this.SCROLL_SENSITIVITY;\r\n        this.scale -= delta;\r\n\r\n        this.clampZoom()\r\n\r\n        // var hex = this.retrieveHexFromMouseEvent(e);\r\n        this.focusHexOnPoint(hex, mouse);\r\n\r\n        this.updateGridTransformation()\r\n\r\n        this.updateHighlightedHex(e);\r\n\r\n    }\r\n\r\n    // set screen margins so hex is on point on screen\r\n    focusHexOnPoint(hex, point) {\r\n        let center = this.hexToPixel(hex);\r\n        center.x *= this.scale;\r\n        center.y *= this.scale;\r\n\r\n        point.x -= (this.dragMargin.x * this.scale);\r\n        point.y -= (this.dragMargin.y * this.scale);\r\n\r\n        this.dragMargin.x -= -(point.x - center.x) / this.scale\r\n        this.dragMargin.y -= -(point.y - center.y) / this.scale\r\n    }\r\n\r\n    handleMouseMove(e) {\r\n        if (this.dragging) {\r\n            var delta = {\r\n                x: (e.clientX - this.lastDragPosition.x) / this.scale,\r\n                y: (e.clientY - this.lastDragPosition.y) / this.scale\r\n            }\r\n            this.lastDragPosition = { x: e.clientX, y: e.clientY }\r\n            this.dragMargin.x += delta.x;\r\n            this.dragMargin.y += delta.y;\r\n\r\n            this.updateGridTransformation()\r\n        }\r\n        this.updateHighlightedHex(e);\r\n    }\r\n\r\n    drawUnitCanvas() {\r\n        var ctx = this.canvasUnits.getContext('2d')\r\n        ctx.clearRect(0, 0, this.canvasHex.width, this.canvasHex.height);\r\n\r\n        ctx.font = \"bold 20px Arial\";\r\n        this.props.board.grid.forEach((column, x) => {\r\n            column.forEach((tile, y) => {\r\n                if (tile.units.length > 0) {\r\n\r\n                    let center = this.hexToPixel(this.HexOffset(x, y))\r\n                    ctx.fillText(tile.units.length, center.x - 5, center.y + 7);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    updateHighlightedHex(e) {\r\n        var hex = this.retrieveHexFromMouseEvent(e);\r\n        if (hex == undefined) return;\r\n        if (hex.x < 0 || hex.x >= this.props.board.columns\r\n            || hex.y < 0 || hex.y >= this.props.board.rows) {\r\n            return;\r\n        }\r\n        this.setState({\r\n            highlightedHex: hex,\r\n        })\r\n    }\r\n\r\n    redrawHexGrid() {\r\n        this.clearHexGrid();\r\n        this.drawHexGrid();\r\n        this.setState({\r\n            redrawOverlay: (this.state as any).redrawOverlay++ || 0\r\n        })\r\n    }\r\n\r\n    drawHexGrid() {\r\n        var ctx = this.canvasHex.getContext('2d');\r\n\r\n\r\n        for (let x = 0; x < this.props.board.columns; x++) {\r\n            for (let y = 0; y < this.props.board.rows; y++) {\r\n                let center = this.hexToPixel(this.HexOffset(x, y))\r\n                this.drawHex(ctx, center, 'black', '4', this.props.board.grid[x][y].color.getStringNotation())\r\n            }\r\n        }\r\n    }\r\n\r\n    clearHexOverlay() {\r\n        var overlayCtx = this.canvasOverlay.getContext('2d')\r\n        overlayCtx.clearRect(0, 0, this.canvasHex.width, this.canvasHex.height);\r\n    }\r\n\r\n    clearHexGrid() {\r\n        var ctx = this.canvasHex.getContext('2d')\r\n        ctx.clearRect(0, 0, this.canvasHex.width, this.canvasHex.height);\r\n    }\r\n\r\n    cubeDirections = [\r\n        this.Cube(1, 0, -1), this.Cube(1, -1, 0), this.Cube(0, -1, 1),\r\n        this.Cube(-1, 0, 1), this.Cube(-1, 1, 0), this.Cube(0, 1, -1)];\r\n\r\n    cubeAdd(CubeA, CubeB) {\r\n        return this.Cube(CubeA.x + CubeB.x, CubeA.y + CubeB.y, CubeA.z + CubeB.z);\r\n    }\r\n\r\n    cubeSubtract(CubeA, CubeB) {\r\n        return this.Cube(CubeA.x - CubeB.x, CubeA.y - CubeB.y, CubeA.z - CubeB.z);\r\n    }\r\n\r\n    getNeighbor(hex, direction) {\r\n        let cube = this.hexOffsetToCube(hex)\r\n        return this.cubeToHexOffset(this.cubeAdd(cube, this.cubeDirections[direction]))\r\n    }\r\n\r\n    getNeighbors(hex) {\r\n        let cube = this.hexOffsetToCube(hex)\r\n        return this.cubeDirections.map((direction) => this.cubeToHexOffset(this.cubeAdd(cube, direction)))\r\n            .filter((hex) => hex.x >= 0 && hex.x < this.props.board.columns && hex.y >= 0 && hex.y < this.props.board.rows)\r\n    }\r\n\r\n    getAllHexCornerCoord(center) {\r\n        return [0, 1, 2, 3, 4, 5].map((i) => this.getHexCornerCoord(center, i))\r\n    }\r\n\r\n    getHexCornerCoord(center, i) {\r\n        var angle_deg = 60 * i + 30;\r\n        var angle_rad = Math.PI / 180 * angle_deg;\r\n        return this.Point(center.x + this.hexSize * Math.cos(angle_rad),\r\n            center.y + this.hexSize * Math.sin(angle_rad))\r\n    }\r\n\r\n    drawHex(ctx, center, lineColor, lineWidth, fillColor?, fillAlpha?) {\r\n        let corners = this.getAllHexCornerCoord(center);\r\n        ctx.beginPath();\r\n        if (fillColor != null)\r\n            ctx.fillStyle = fillColor;\r\n        // if (fillAlpha != null)\r\n        //     ctx.globalAlpha = fillAlpha;\r\n        ctx.strokeStyle = lineColor;\r\n        ctx.lineWidth = lineWidth;\r\n\r\n        ctx.moveTo(corners[corners.length - 1].x, corners[corners.length - 1].y);\r\n        corners.forEach((c) => {\r\n            ctx.lineTo(c.x, c.y);\r\n            ctx.stroke();\r\n        })\r\n\r\n        ctx.closePath();\r\n        if (fillColor != null)\r\n            ctx.fill();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"canvasContainer\" ref={canvasContainer => this.canvasContainer = canvasContainer}>\r\n                <canvas ref={canvasHex => this.canvasHex = canvasHex}> </canvas>\r\n                <canvas ref={canvasUnits => this.canvasUnits = canvasUnits}></canvas>\r\n                <canvas ref={canvasOverlay => this.canvasOverlay = canvasOverlay}\r\n                    onMouseOut={this.handleMouseOut.bind(this)}\r\n                    onMouseUp={this.handleMouseUp.bind(this)}\r\n                    onMouseDown={this.handleMouseDown.bind(this)}\r\n                    onMouseMove={this.handleMouseMove.bind(this)}\r\n                    onWheel={this.handleWheel.bind(this)}>\r\n                </canvas>\r\n            </div >\r\n        )\r\n    }\r\n\r\n    // oddR offset to pixel\r\n    hexToPixel(hex) {\r\n        var x = this.hexSize * (Math.sqrt(3) * (hex.x + 0.5 * (hex.y & 1))) + this.hexOrigin.x;\r\n        var y = this.hexSize * (3 / 2 * hex.y) + this.hexOrigin.y;\r\n        return this.Point(x, y)\r\n    }\r\n\r\n    pixelToHex(point) {\r\n        let q = ((point.x - this.hexOrigin.x) * Math.sqrt(3) / 3 - (point.y - this.hexOrigin.y) / 3) / this.hexSize;\r\n        let r = (point.y - this.hexOrigin.y) * 2 / 3 / this.hexSize;\r\n        return this.cubeToHexOffset(this.cubeRound(this.Cube(q, -q - r, r)))\r\n    }\r\n\r\n    cubeRound(cube) {\r\n        var rx = Math.round(cube.x)\r\n        var ry = Math.round(cube.y)\r\n        var rz = Math.round(cube.z)\r\n\r\n        var x_diff = Math.abs(rx - cube.x)\r\n        var y_diff = Math.abs(ry - cube.y)\r\n        var z_diff = Math.abs(rz - cube.z)\r\n\r\n        if (x_diff > y_diff && x_diff > z_diff) {\r\n            rx = -ry - rz\r\n        } else if (y_diff > z_diff) {\r\n            ry = -rx - rz\r\n        } else {\r\n            rz = -rx - ry\r\n        }\r\n        return this.Cube(rx, ry, rz)\r\n    }\r\n\r\n    hexOffsetRound(hex) {\r\n        return this.cubeToHexOffset(this.cubeRound(this.hexOffsetToCube(hex)));\r\n    }\r\n\r\n    cubeToHexOffset(cube) {\r\n        var x = cube.x + (cube.z - (cube.z & 1)) / 2\r\n        var y = cube.z;\r\n        return this.HexOffset(x, y);\r\n    }\r\n\r\n    hexOffsetToCube(hex) {\r\n        var x = hex.x - (hex.y - (hex.y & 1)) / 2\r\n        var z = hex.y;\r\n        var y = -x - z;\r\n        return this.Cube(x, y, z);\r\n    }\r\n\r\n    Point(x, y) {\r\n        return { x: x, y: y }\r\n    }\r\n\r\n    HexOffset(x, y) {\r\n        return {\r\n            x: x,\r\n            y: y,\r\n        }\r\n    }\r\n\r\n    Cube(x, y, z) {\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            z: z\r\n        }\r\n    }\r\n\r\n    clamp(num, min, max) {\r\n        return num <= min ? min : num >= max ? max : num;\r\n    }\r\n\r\n}","D:\\Projects\\HexGridGame\\src\\Color.tsx",["91"],"export class Color {\r\n\r\n    h: number\r\n    s: number\r\n    l: number\r\n\r\n    getStringNotation() {\r\n        return `hsl(${this.h},${this.s}%, ${this.l}%)`\r\n    }\r\n\r\n    getOppositeStringNotation() {\r\n        if (this.s == 0) {\r\n            return `hsl(${this.h},${this.s}%, 100%)`\r\n        } else {\r\n            return `hsl(${this.h + 180 % 360},${this.s}%, ${this.l}%)`\r\n        }\r\n    }\r\n\r\n    mergeColor(color2: Color) {\r\n        if (color2.h != null && color2.h >= 0 && color2.h <= 360) {\r\n            if (Math.abs(this.h - color2.h) > 180)\r\n                this.h = (this.h + 360 + color2.h) / 2 % 360;\r\n            else\r\n                this.h = (this.h + color2.h) / 2 % 360;\r\n        }\r\n    }\r\n\r\n    constructor(h, s, l) {\r\n        this.h = h;\r\n        this.s = s;\r\n        this.l = l;\r\n    }\r\n}","D:\\Projects\\HexGridGame\\src\\components\\index.js",[],"D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\index.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\Button\\index.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\Modal\\index.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\ProgressBar\\index.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CentralButton.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CircleMenuWrapper.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\SubMenuItem.jsx",[],"D:\\Projects\\HexGridGame\\src\\components\\CircleMenu\\CircleMenuItem.jsx",[],{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","replacedBy":"95"},{"ruleId":"96","severity":1,"message":"97","line":150,"column":44,"nodeType":"98","messageId":"99","endLine":150,"endColumn":46},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","replacedBy":"95"},{"ruleId":"100","severity":1,"message":"101","line":1,"column":17,"nodeType":"102","messageId":"103","endLine":1,"endColumn":26},{"ruleId":"100","severity":1,"message":"104","line":2,"column":18,"nodeType":"102","messageId":"103","endLine":2,"endColumn":23},{"ruleId":"105","severity":1,"message":"106","line":14,"column":5,"nodeType":"107","messageId":"108","endLine":16,"endColumn":6},{"ruleId":"100","severity":1,"message":"109","line":3,"column":10,"nodeType":"102","messageId":"103","endLine":3,"endColumn":15},{"ruleId":"105","severity":1,"message":"106","line":55,"column":5,"nodeType":"107","messageId":"108","endLine":57,"endColumn":6},{"ruleId":"96","severity":1,"message":"110","line":86,"column":24,"nodeType":"98","messageId":"99","endLine":86,"endColumn":26},{"ruleId":"111","severity":1,"message":"112","line":97,"column":25,"nodeType":"102","messageId":"113","endLine":97,"endColumn":31},{"ruleId":"111","severity":1,"message":"114","line":98,"column":25,"nodeType":"102","messageId":"113","endLine":98,"endColumn":29},{"ruleId":"96","severity":1,"message":"97","line":148,"column":21,"nodeType":"98","messageId":"99","endLine":148,"endColumn":23},{"ruleId":"96","severity":1,"message":"97","line":148,"column":60,"nodeType":"98","messageId":"99","endLine":148,"endColumn":62},{"ruleId":"96","severity":1,"message":"97","line":292,"column":17,"nodeType":"98","messageId":"99","endLine":292,"endColumn":19},{"ruleId":"96","severity":1,"message":"97","line":12,"column":20,"nodeType":"98","messageId":"99","endLine":12,"endColumn":22},"no-native-reassign",["115"],"no-negated-in-lhs",["116"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","@typescript-eslint/no-unused-vars","'Component' is defined but never used.","Identifier","unusedVar","'Modal' is defined but never used.","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'Color' is defined but never used.","Expected '!==' and instead saw '!='.","@typescript-eslint/no-redeclare","'center' is already defined.","redeclared","'tile' is already defined.","no-global-assign","no-unsafe-negation"]